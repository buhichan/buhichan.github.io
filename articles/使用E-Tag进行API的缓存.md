我在工作中遇到一个需要对Restful GET API查询性能进行优化的需求, 这里我用了一个ETag缓存机制来进行缓存, 下面讲一下是怎么做的.

# [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag)

ETag是一个HTTP响应头, 前端请求了一个资源之后, 如果收到了这个ETag, 那么下一次请求同一个资源的时候就会将ETag的值放进If-None-Match这个请求头里, 用来让后端决定是否需要:
    - If-None-Match的值与当前ETag不符, 需要让浏览器再次下载资源
    - If-None-Match的值与当前ETag相符, 浏览器跳过下载, 使用浏览器端缓存的响应

可以看出, 如果我们的资源是一个文件的话, 那么可以用随便一个摘要算法用来做它的ETag值.

如果是一个GET API呢, 是不是也可以使用这个机制呢?

# 使用E-TAG对GET请求进行缓存

- 前提
    - 请求频率/更新频率的比值较大的api, 例如一个对某种不频繁的时序数据进行全量统计查询的api
    - 如果后端时序数据没有更新, 则同样的参数返回同样的结果
- 机制
    - 将每种查询结果对待成一种虚拟的文件
    - 给每种参数组合的查询结果分配版本号, 可以是一个自增整数, 如果自增整数溢出则从0开始.
    - 有一个请求参数的hash函数, 例如 request=>request.url.search
    - 有一个redis的hash表存储requestHash:latestVersion的键值对
    - 服务端响应头加上 etag: latestVersion
    - 当数据更新, 对版本号进行更新, 使得etag失效
    - 当请求中有if-none-match, 如果请求的hash和if-none-match的键值对存在于hash表中, 则返回304, 并跳过对查询的处理
- 优点
    - 并不存储数据本身, 因此内存占用量较普通的直接存储查询结果要小
- 缺点
    - n个用户访问同一个资源, 并不能只处理1次请求, 而是需要处理n次请求
    - 需要定期清理hash表
    - 适用情景的面比较窄, 访问频率越大, 数据更新频率越小, 则命中率越高
- 其他方案
    - 如果对API的访问端有完全的控制权, 可以去掉所有的轮询, 改用websocket发送数据改变事件, 前端收到改变事件的时候才进行查询.

# 效果
因为API被轮询, 在我的生产环境中能达到0.8的命中率

# 关联知识

[CQRS](https://www.jianshu.com/p/1b82a1f6a586)