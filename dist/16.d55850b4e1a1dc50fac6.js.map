{"version":3,"sources":["webpack:///./src/routes/fractal/segments.tsx"],"names":["defaultRands","Math","random","Fractal","ref","rands","setRands","edge","setEdge","loop","setLoop","current","width","W","height","H","parentElement","getBoundingClientRect","U","min","雪花","layer","雪花Inner","line","curLayer","res","i","length","push","p1","p2","j","k1","k2","pipe","minus","v1","v2","add","multi","makeFractal","points","Array","fill","map","_","cos","PI","sin","path","reduce","x","context2d","getContext","clearRect","window","innerWidth","innerHeight","beginPath","translate","strokeStyle","moveTo","point","lineTo","stroke","onClick","style","type","step","value","onChange","e","currentTarget","color","key","max","copy","slice","Number","fn","p","f"],"mappings":"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","file":"16.d55850b4e1a1dc50fac6.js","sourcesContent":["import * as React from \"react\"\nimport { interval } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\n\nconst defaultRands = ()=>[\n    [Math.random() * 0.4,Math.random() * 0.4],\n    [Math.random() * 0.4 + 0.2,Math.random() * 0.4],\n    [Math.random() * 0.4 + 0.4,Math.random() * 0.4],\n    [Math.random() * 0.4 + 0.8,Math.random() * 0.4],\n] as Point[]\n\nexport default function Fractal(){\n    const ref = React.useRef(null as null | HTMLCanvasElement)\n\n    const [rands,setRands] = React.useState(defaultRands)\n\n    const [edge,setEdge] = React.useState(3)\n\n    const [loop,setLoop] = React.useState(6)\n\n\n    React.useEffect(()=>{\n        if(ref.current){\n            const {width:W,height:H} = ref.current.parentElement.getBoundingClientRect()\n            const U = Math.min(W,H)\n            ref.current.height = U * 2\n            ref.current.width = U * 2\n\n            if(edge < 3){\n                return \n            }\n            if(loop < 0){\n                return\n            }\n\n            const 雪花 = makeFractal(rands,loop)\n\n            const points:Point[] = new Array(edge).fill(0).map((_,i)=>{\n                return [\n                    Math.cos(Math.PI * 2 / edge * i) * U / 2,\n                    Math.sin(Math.PI * 2 / edge * i) * U / 2 ,\n                ]\n            })\n            \n            const path = points.reduce((path,x,i)=>[\n                ...path,\n                ...雪花([points[i],i === points.length - 1 ? points[0] : points[i+1]]),\n            ],[] as Point[])\n\n            const context2d = ref.current.getContext('2d')\n            if(context2d){\n                // let anime = requestAnimationFrame(function render(){\n                    context2d.clearRect(0,0,window.innerWidth,window.innerHeight)\n                    context2d.beginPath()\n                    context2d.translate(U,U)\n                    context2d.strokeStyle = \"#000\"\n                    context2d.moveTo(...path[0])\n                    for(let point of path){\n                        context2d.lineTo(...point)\n                    }\n                    context2d.stroke()\n                    // anime = requestAnimationFrame(render)\n                // })\n                // return ()=>cancelAnimationFrame(anime)\n            }\n        }\n    },[loop,edge,rands])\n\n\n    return <div>\n        <h2>简单的线段分形</h2>\n        <canvas onClick={()=>{\n            setRands(defaultRands())\n        }} ref={ref} style={{\n            width:\"100%\",\n            height:\"100%\",\n        }} />\n        <div>\n            <p>简单的线段分形, 从一个正多边形派生出的分形.</p>\n        </div>\n        <div>\n            <label>起始图像边数</label>\n            <input type=\"number\" min={3} step={1} value={edge} onChange={e=>setEdge(+e.currentTarget.value)} />\n        </div>\n        <div>\n            <label>循环次数</label>\n            <input type=\"number\" min={0} step={1} value={loop} onChange={e=>setLoop(+e.currentTarget.value)} />\n            <p style={{color:\"#999\"}}>注意: 分形是由你的浏览器计算的, 所以如果循环次数太高你的浏览器会很卡</p>\n        </div>\n        <div>\n            <div>种子:</div>\n            {\n                rands.map((x,i)=>{\n                    return <div key={i}>\n                        <div>\n                            <label>x</label>\n                            <input style={{width:200}} value={x[0]} type=\"number\" min={-1} max={1} step={0.1} onChange={(e)=>{\n                                const copy = rands.slice()\n                                copy[i] = copy[i].slice() as Point\n                                copy[i][0] = Number(e.currentTarget.value)\n                                setRands(copy)\n                            }}></input>\n                        </div>\n                        <div>\n                            <label>y</label>\n                            <input style={{width:200}} value={x[1]} type=\"number\" min={-1} max={1} step={0.1} onChange={(e)=>{\n                                const copy = rands.slice()\n                                copy[i] = copy[i].slice() as Point\n                                copy[i][1] = Number(e.currentTarget.value)\n                                setRands(copy)\n                            }}></input>\n                        </div>\n                    </div>\n                })\n            }\n        </div>\n    </div>\n}\n\ntype Point = [number,number]\n\nfunction makeFractal(rands:Point[], layer:number){\n    \n    return function 雪花Inner (line:Point[],curLayer = layer):Point[]{\n        if(curLayer === 0){\n            return line\n        }\n        let res:Point[] = []\n        let i = 0\n        while(i < line.length - 1){\n            res.push(line[i])\n            let p1 = line[i]\n            let p2 = line[i+1]\n            for(let j=0;j<rands.length;j++){\n                let [k1,k2] = rands[j]\n                res.push(\n                    pipe(\n                        minus(p2),\n                        (v1)=>{\n                            const v2 = [-v1[1],v1[0]] as Point\n                            return add(multi(k1)(v1))(multi(k2)(v2))\n                        },\n                        add(p1)\n                    )(p1)\n                )\n            }\n            i += 1\n        }\n        res.push(line[line.length - 1])\n        return 雪花Inner(res,curLayer - 1)\n    }\n}\n\nfunction pipe(...fn:((p:Point)=>Point)[]){\n    return (p:Point)=>fn.reduce((p,f)=>f(p),p)\n}\n\nfunction add(v2:Point){\n    return (v1:Point)=>[\n        v1[0] + v2[0], \n        v1[1] + v2[1]\n    ] as Point\n}\n\nfunction multi(v2:number){\n    return (v1:Point)=>[\n        v1[0] * v2,\n        v1[1] * v2\n    ] as Point\n}\n\nfunction minus(v2:Point){\n    return (v1:Point)=>[\n        v2[0] - v1[0], \n        v2[1] - v1[1]\n    ] as Point\n}\n\nfunction rotate(rad:number){ //counter-clockwise\n    return (v:Point)=>[\n        v[0] * Math.cos(rad) - v[1] * Math.sin(rad),\n        v[0] * Math.sin(rad) + v[1] * Math.cos(rad),\n    ] as Point\n}\n\nfunction between(p2:Point,n:number){\n    return (p1:Point)=>[p1[0] * (1-n) + p2[0] * n, p1[1] * (1-n) + p2[1] * n] as Point\n}"],"sourceRoot":""}