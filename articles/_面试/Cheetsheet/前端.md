
# 2020

---

# 2019

## OSI Model / TCP/IP Model

- Layer 1: Physical Layer 物理层
- Layer 2: Data Link Layer 数据链路层
- Layer 3: Network Layer 网络层 
- Layer 4: Transport Layer 传输层 
- Layer 5: Session Layer 会话层
- Layer 6: Presentation Layer 表达层 
- Layer 7: Application Layer 应用层

TCP/IP模型中, 5~7层被省略合称为应用层, 因此只有5层

## 浏览器输入一个URL回车之后发生了什么

- 查找 DNS 缓存
    - 有下列几级缓存
        - DNS 浏览器缓存
        - DNS 本地缓存
            - hosts 文件
        - DNS 路由器缓存
        - DNS ISP缓存
    - 如果没有缓存则DNS运营商的服务器会发一个DNS解析请求到根域名服务器
- DNS lookup
    - udp协议
    - 有一个flag告诉服务器要不要递归查询
        - DNS解析器查询根域名服务器
        - DNS解析器查询一级域名服务器
        - DNS解析器查询二级域名服务器
        - ...
    - 返回记录,如果没有就失败了
- TCP 连接 (网络层)
    - 三次握手
        - SYN
            - 客户端请求建立连接
        - SYN+ACK
            - 服务端根据自己判断(例如port是否已经用完了),
        - ACK
    - 后续
        - ACK & ACK Number
- TLS 握手 (大概是会话层, 其实很模糊)
    - client hello
    - server hello
        - certificate
        - server hello done
    - client
        - client key exchange
        - change cipher spec
        - finished
    - server
        - change cipher spec
        - finished
    - TLS 为什么可以防御中间人攻击
        - 非对称加密签名和CA(certificate authority, 证书授权)保证了签名即使被伪造了也无法跟域名对应
    - TCP 握手 + TLS握手加起来是 3 + 4 - 1 = 6次握手, 因为Client ACK跟Client Hello是同一次
        - ![tls-ssl-handshake](assets/tls-ssl-handshake.png)
- HTTP请求
- HTTP响应
- HTML Parser
    - DOM Parse
    - 遇到script
        - ![script_async_defer_explained](assets/script_async_defer_explained.jpeg)
    - 遇到link/style
        - parse css
        - 这里会有问题, 如果css加载完成的时间点不确定, 则js代码请求样式的结果不确定
            - Firefox: 在parse css的时候会阻塞掉js的执行
            - Webkit: 在js请求被还未加载完成的css影响的样式的时候阻塞掉其执行
    - parse html结束
    - 合成render tree
    - layout
    - render
    - DOMContentLoaded
    - before load
        - defered script execution
        - apply style fetched through link element
        - load resources: images, iframes
    - load
    - execute js
    - first idle frame



## 浏览器缓存机制

前端缓存加速的基本方案

下面部分文字直接摘抄自[这位大佬](http://qingbob.com/cache-design/). 浏览器缓存机制基本的顺序是 

1. Memory Cache
    - “内存缓存”中主要包含的是当前文档中页面中已经抓取到的资源。例如页面上已经下载的样式、脚本、图片等。我们不排除页面可能会对这些资源再次发出请求，所以这些资源都暂存在内存中，当用户结束浏览网页并且关闭网页时，内存缓存的资源会被释放掉。

    - 这其中最重要的缓存资源其实是preloader相关指令（例如<link rel="prefetch">）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，而通过这些指令下载的资源也都会暂存到内存中。根据一些材料，如果资源已经存在于缓存中，则可能不会再进行preload。
    需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验
    - Memory cache 持久化之后就是disk cache
    - Memory cache 跟 Cache-Control无关
2. Service Worker
    - Service worker主要靠拦截fetch请求和cacheStorage缓存 (此处需要补充)
    - 虽然Service worker优先级在HTTP Cache之前, 但是使用了sw, 并不代表就disable了http cache, 如果此时设置了 cache-control: <1年的秒数>,则会出现缓存了失效资源的问题. 所以我们必须要设置cache-control: no-cache 来绕过HTTP Cache. 在TL这个项目上我遇到过这个坑.
3. HTTP Cache
    1. HTTP1.0
        - Expires 一个时间点
    2. HTTP1.1
        1. Cache-Control
            1. No-store
                - 表示不缓存
            2. No-cache
                - 表示使用缓存之前要向服务器验证
            3. Max-age, must-revalidate
                - 表示缓存新鲜(存活小于max-age)则可以不必验证, 否则应该(must-revalidate: 必须)验证
        2. Last-Modified
            - If-Modified-Since
        3. Etag
            1) If-None-Match
    3. HTTP Cache的顺序是
        1. no-store ? 
        2. no-cache ?
        3. public ? 
        4. max-age/expire
        5. e-tag
    4. Expires, max-age称为强缓存
    5. last-modified和ETag为协商缓存(服务器仍然需要少量处理)
            
4. Push “Cache”
    - http2 的 push机制提供的缓存方法

有serviceworker 用 serviceworker
没有就etag/if-none-match
Etag不合适就cache-control

## JS性能优化

> One large change to the cost of JavaScript over the last few years has been an improvement in how fast browsers can parse and compile script. In 2019, the dominant costs of processing scripts are now download and CPU execution time.
>
> -- <cite>[https://v8.dev/blog/cost-of-javascript-2019](https://v8.dev/blog/cost-of-javascript-2019)</cite>

- 优化下载时间
    - 减少单个脚本大小到50K-100K左右
    - &lt;preload /&gt; 标签
    - 上http2
        - http2复用http连接, 对同时多请求的支持好
    - 给script 标签加上async
- 优化执行时间
    - 使用profiler优化执行时间长的函数 ( Long Task )
- 避免inline script 标签

## HTML Parser

- preload scan
    - script, preload, ... 
        - download
- parse html to dom 
- parse css to cssom 

## React Diff

- single element
    - diff element type
    - if element is pure class component / memoized SFC
        - use shouldComponentUpdate or the function received by React.memo to diff props
            - true => rerender
            - false => not changed
    - rerender
- array
    - diff by key
    - run twice, first collect map


## React Suspence

- 原理
    - React.lazy 创建的vdom, 属于特殊的类别LazyComponent
    - reconciler遇到一个pending的LazyComponent, 则丢出一个Promise, 跳过剩余的不必要的渲染(bail out)
    - workloop捕获到一个Promise, 则会找到离此lazyComponent最近的祖先Suspence, 为其等待队列添加这个Promise, 然后从这里重新渲染
    - Suspence暂时渲染fallback, 其队列的所有Promise都resolve之后重新渲染
        - 虽然suspence显示fallack了, 但是后台fiber会继续从抛出promise的fiber的sibling(或者是从suspence的child? 这点还没看)继续渲染, 保证触发所有的throw Promise, 因此suspence下多个并列组件内throw Promise, 会同时开始waiting, 而不是上一个resolve之后下一个才触发

## Rxjs

- rxjs替代redux
    - 方案
        - 不再有单个中心化的store, 而是多个BehaviorSubject
    - Pros
        - 不再需要reselect redux-saga redux-observable
            - 减少了接口的表面积
        - 存在多种操作符, 可以提高开发效率 
            - 例如 switchMap + fetch + abortController
        - redux违背了separate of concern, 而rxjs可以是完美符合
    - Cons
        - 丧失了状态中心化带来的好处
            - time travel
            - 测试性
            - 解决办法: 跟一个redux store双向同步
        - rxjs与react的功能有重叠之处, 实际上可以基于rxjs开发view层了.

- observable
    - 冷热
        - 冷的是订阅的时候运行, 并且每一个订阅者的消息都是相对于订阅者自己独立的
	    - 热的是自己就会运行, 并且所有订阅者的消息都是时间上绝对的.
        
- multicast 
    - 冷变热, 创建一个ConnectableObservable
- publish 
    - 跟multicast一样, 不过不需要传入subject, 而是内部创建subject
- refCount 
    - 统计对一个ConnectableObservable的订阅, 当且仅当订阅数从0到1时候, 创建一个订阅, 从1到0的时候退订.
- share
    - 等同于 publish + refCount


---

# NodeJS 

## Webpack 插件

主要有一个概念: Tapable, Tapable表示插件的钩子接口, Tapable可以有3种类型

- 同步
- 同步可跳出(SyncBail)
- 异步并行
- 异步串行

根据是否为同步tapable可以有钩子和异步钩子回调.

<details>
<summary>例如</summary>
```js
{
    apply(compiler) {
        compiler.hooks.compilation.tap("Create article list", (compilation)=>{
            compilation.hooks.additionalAssets.tapAsync(
                "Create article list",
                async () => {
                  const fsReaddir = promisify(fs.readdir);
                  const fsStat = promisify(fs.stat);
                  const walk = async (absPath) => {
                    const res = {};
                    const contents = await fsReaddir(absPath, "utf-8");
                    await Promise.all(
                      contents.map(async (fileName) => {
                        const childPath = path.join(absPath, fileName);
                        if(fileName.startsWith("_")){
                            return
                        }
                        const stats = await fsStat(childPath);
                        if (stats.isDirectory()) {
                          res[fileName] = walk(childPath);
                        } else {
                          res[fileName] = {
                            modifyTime: stats.mtimeMs
                          };
                        }
                      })
                    );
                    return res;
                  };
                  const articles = await walk(path.resolve("./articles"));
                  compilation.assets["articlelist.js"] = `var articleList = ${JSON.stringify(articles)}`
                }
            )
        })
      },
}
```
</details>

## File System Flags

The following flags are available wherever the flag option takes a string.

- a 表示appending
- r 表示只读
- w 表示只写
- x 表示如果文件不存在, 则报错
    - 不加x的默认行为是创建, 但是不会往上追溯, 也就是不会出现mkdir -p那种
- + 表示同时允许读写
- s 同步模式

但是并不是可以任意组合的, 合法的组合为

- 'a': Open file for appending. The file is created if it does not exist.
- 'ax': Like 'a' but fails if the path exists.
- 'a+': Open file for reading and appending. The file is created if it does not exist.
- 'ax+': Like 'a+' but fails if the path exists.
- 'as': Open file for appending in synchronous mode. The file is created if it does not exist.
- 'as+': Open file for reading and appending in synchronous mode. The file is created if it does not exist.
- 'r': Open file for reading. An exception occurs if the file does not exist.
- 'r+': Open file for reading and writing. An exception occurs if the file does not exist.
- 'rs+': Open file for reading and writing in synchronous mode. Instructs the operating system to bypass the local file system cache.
    - This is primarily useful for opening files on NFS mounts as it allows skipping the potentially stale local cache. It has a very real impact on I/O performance so using this flag is not recommended unless it is needed.
    - This doesn't turn fs.open() or fsPromises.open() into a synchronous blocking call. If synchronous operation is desired, something like fs.openSync() should be used.
- 'w': Open file for writing. The file is created (if it does not exist) or truncated (if it exists).
- 'wx': Like 'w' but fails if the path exists.
- 'w+': Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).
- 'wx+': Like 'w+' but fails if the path exists.

## 同步/异步 阻塞/非阻塞
同步阻塞 同步非阻塞 异步阻塞 异步非阻塞
- 阻塞指的是调用方的状态 
    - 作为公理必须定义什么叫阻塞才能继续下面的推论
    - 比如把 “线程在等待的过程中无法继续其他的工作” 作为阻塞的定义
- 异步同步指的是过程的性质
- 阻塞指一个调用方需要等待一个状态发生改变才能继续
- 异步指的是一个过程调用方调用之后可以立即返回,并不傻等
- 同步阻塞:  while(lockIsNotFree()){}
- 同步非阻塞: while(lockIsNotFree()){ doSomethingElse() }
- 异步阻塞:  比如push到一个消息队列, 但是消息队列在等待一个锁
- 异步非阻塞:  比如push到一个消息队列, 消息队列下发到消费者


## 前端性能优化

- 网络方面：CDN、gzip、缓存；
- 代码方面：合包、压缩、拆包、defer；
- 数据方面：各种缓存策略；
- 图片方面：压缩、baseb4、精灵图、转 SVG、懒加载、缩略图、webp；

- 首屏加载和按需加载，非首屏内容滚屏加载，保证首屏内容最小化
- 模块化资源并行下载
- inline 首屏必备的 CSS 和 JavaScript
- meta dns prefetch 设置 DNS 预解析
    - ```html
        <!--cdn域名预解析-->
        <meta http-equiv="x-dns-prefetch-control" content="on" >
        <link rel="dns-prefetch" href="//cdn.domain.com" >
    ```
- 资源预加载:对于移动端首屏加载后可能会被使用的资源，需要在首屏完成加载后尽快进行加载，保证在用户需要浏览时已经加载完成
- 尝试使用 PWA 模式
- 图片压缩处理
    - 使用较小的图片，合理使用 base64 内嵌图片
    - 使用更高压缩比格式的图片：webp格式
    - 图片懒加载
    - 使用 iconfont 代替图片图标

## 正则表达式 
[贪婪模式与非贪婪模式](https://www.jianshu.com/p/fcecf9b09ee6)

```js
//贪婪
//.会匹配到尽可能多的字符, 然后如果不行再倒过来
//在贪婪（默认）模式下，正则引擎尽可能多的重复匹配字符。
var str = 'a "witch" and her "broom" is one';
str.match( /".*"/g);    //"witch" and her "broom"

//非贪婪
//.会匹配到尽可能少的字符, 匹配到一个马上尝试能不能匹配.的下一个字符,这里是"
//非贪婪模式和贪婪模式相反，可通过在代表数量的标识符后放置?来开启非贪婪模式，如?、+?甚至是??。
//在非贪婪模式下，正则引擎尽可能少的重复匹配字符。
var str = 'a "witch" and her "broom" is one';
str.match(/".*?"/g )     // "witch", "broom"
```


## 设计模式  
- cqrb 
- cqrs
    - Command Query Responsibility Segregation

- setTimeout是不是准时的
	- 主线程被阻塞了就不是

- requestAnimationFrame原理
	- 在下次重绘之前调用我们的回调
	- 背景tab不会调用

- 怎么判断promise是不是原生promise
	- 判断是不是微任务
	- 但是如果是用queueMicroTask这个方法写的poly fill就没办法了

- hidden class原理

- node的事件循环跟Chrome的事件循环有什么区别

- 除了promise then还有哪些属于微任务
	- queueMicroTask 
	- import("foo.js") ??? 不确定

- 用什么东西可以查看一个函数有没有被jit优化