(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{"./src/routes/fractal/shaders/newton-fractal.glsl":function(n,e,o){"use strict";o.r(e),e.default="#version 300 es\nprecision highp float;\n\n// 所谓的牛顿分形, 就是用牛顿法计算某方程式的解的时候, \n// 如果把屏幕上的每个点按照它们最后会收敛到方程式的第几个根来着色的话,\n// 会形成的一种分形, 以下是 z^3 - 1.0 的牛顿分形,\n// 把鼠标接近 1.0,0.0 可以看到效果\n// 所谓牛顿法\n// 就是循环计算z = z - fn(z) / fnPrime(z),直到z足够接近fn的根.\n\nuniform vec2 resolution;\nin vec3 vPos;\nin vec2 vUv;\nout vec4 color;\nuniform vec2 translate;\nuniform float zoom;\n\n//参数z控制循环次数\nuniform vec3 params;\nuniform float time;\nuniform vec2 mouse;\n\nconst float epsilon = 0.01;\n\n \nconst float PI = 3.1415916;\n\n#include <hsl2rgb>;\n#include <complex>;\n\n\nvec2 fn(vec2 z){\n    //修改这行来查看不同的图案!!!❤️\n    return complexPow(z, 3.0) - vec2(1.0,0.0) - time / 1000.0;\n}\n\nconst vec2 deltaZ = vec2(epsilon,epsilon);\n\nvec2 fnPrime(vec2 z){\n    return complexDiv( fn(z + deltaZ) - fn(z), deltaZ );\n}\n\nvec3 newtonFractal(vec2 z, vec2 c){\n    float l = 0.0;\n    float loop = 0.0;\n    int maxIteration = 150;\n    for(int i=0; i<maxIteration; i++){\n        // newton's fractal for z^3 - 1\n        z = z - complexDiv( fn(z),  fnPrime(z) );\n        loop += 1.0;\n        if(length(fn(z)) < epsilon){\n            return vec3(z.xy,z.y/z.x);\n        }\n        // if(distance(root1, z) < epsilon){\n        //     return vec3(0.5,1.0,1.0);\n        // }\n        // if(distance(root2, z) < epsilon){\n        //     return vec3(1.0,0.5,1.0);\n        // }\n        // if(distance(root3, z) < epsilon){\n        //     return vec3(1.0,1.0,0.5);\n        // }\n    }\n    return vec3(1.0,1.0,1.0);\n}\n\nvoid main(){\n    vec2 point = ( vUv.xy + translate / resolution ) * zoom * 2.0 - 1.0;\n    vec3 res = newtonFractal(point,mouse);\n    color = vec4(res.xyz, 1.0);\n}"}}]);
//# sourceMappingURL=23.a618ad4592911781178f.js.map